#! /bin/bash

LOG_LEVEL="warning"
YT_DLP="FALSE"
INPUT_FILE=""
REFERER=""
M3U8=FALSE
DOWNLOAD_INDEX=0
N16=$(cat /dev/urandom | tr -dc '1-9' | head -c16)
RECONNECT=TRUE
START_TIME=""
END_TIME=""
VARIABLE_FRAME_RATE=FALSE
AUDIO=TRUE
ROTATE="0"
CROP=""
ASPECT=""

while getopts ":-:" OPT; do
  OPT="-${OPT}${OPTARG}"
  OPTARG="${!OPTIND}"
  if [ "${OPT}" = "--log-level" ]; then
    LOG_LEVEL="${OPTARG}"
    shift
  elif [ "${OPT}" = "--yt-dlp" ]; then
    YT_DLP="TRUE"
  elif [ "${OPT}" = "--input-file" ]; then
    INPUT_FILE="${OPTARG}"
    shift
  elif [ "${OPT}" = "--referer" ]; then
    REFERER="${OPTARG}"
    shift
  elif [ "${OPT}" = "--m3u8" ]; then
    M3U8=TRUE
  elif [ "${OPT}" = "--no-reconnect" ]; then
    RECONNECT=FALSE
  elif [ "${OPT}" = "--start" ]; then
    START_TIME="${OPTARG}"
    shift
  elif [ "${OPT}" = "--end" ]; then
    END_TIME="${OPTARG}"
    shift
  elif [ "${OPT}" = "--variable-frame-rate" ]; then
    VARIABLE_FRAME_RATE=TRUE
  elif [ "${OPT}" = "--no-audio" ]; then
    AUDIO=FALSE
  elif [ "${OPT}" = "--rotate" ]; then
    ROTATE="${OPTARG}"
    shift
  elif [ "${OPT}" = "--crop" ]; then
    CROP="${OPTARG}"
    shift
  elif [ "${OPT}" = "--aspect" ]; then
    ASPECT="${OPTARG}"
    shift
  else
    echo "Undefined option: ${OPT} ${OPTARG}"
    exit 1
  fi
done

if [ "${M3U8}" = "TRUE" ]; then
  INPUT_FILE_DIR="$(dirname ${INPUT_FILE})/"
  DOWNLOAD_INDEX=$(ls download*.m3u8 2>/dev/null | wc -l)
  CURL_HEADER=""
  if [ ! "${REFERER}" = "" ]; then
    CURL_HEADER="-H 'Referer: ${REFERER}'"
  fi
  echo "curl ${CURL_HEADER} \"${INPUT_FILE}\" | strings"
  curl ${CURL_HEADER} "${INPUT_FILE}" | strings > download${DOWNLOAD_INDEX}.m3u8
  for e in jpeg jpg mp4 png; do
    cat download${DOWNLOAD_INDEX}.m3u8 | sed -r "s/\.${e}$/\.ts/;s/^(()|(#.*)|(https?:\/\/.*))$/\1/;t;s/^/${INPUT_FILE_DIR//\//\\/}/" > fixed.m3u8
    mv fixed.m3u8 download${DOWNLOAD_INDEX}.m3u8
  done
  vim download${DOWNLOAD_INDEX}.m3u8
  INPUT_FILE=download${DOWNLOAD_INDEX}.m3u8
  RECONNECT=FALSE
fi

FFMPEG_INPUT_OPT="-loglevel ${LOG_LEVEL} -err_detect ignore_err"
FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -fflags +discardcorrupt"
FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -protocol_whitelist crypto,data,file,https,tcp,tls"
FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -user_agent \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36\""
if [ ! "${REFERER}" = "" ]; then
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -referer ${REFERER}"
fi
if [ "${RECONNECT}" = "TRUE" ]; then
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 12"
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -multiple_requests 1"
fi
if [ "${M3U8}" = "TRUE" ]; then
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -seg_max_retry 12 -max_reload 1 -rw_timeout 3000000"
fi
if [ "${START_TIME}" != "" ]; then
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -ss ${START_TIME}"
fi
if [ "${END_TIME}" != "" ]; then
  FFMPEG_INPUT_OPT="${FFMPEG_INPUT_OPT} -to ${END_TIME}"
fi
FFMPEG_OUTPUT_OPT="-tag:v hvc1 -movflags +faststart"
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -max_muxing_queue_size 9999"
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -c:v libx265 -level:v 4.0"
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -b_strategy 2 -bf 2"
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -flags cgop -coder ac -pix_fmt yuv420p -crf 18"
if [ "${VARIABLE_FRAME_RATE}" = "TRUE" ]; then
  FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -fps_mode vfr"
fi
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -bufsize 100M"
if [ "${AUDIO}" = "TRUE" ]; then
  FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -map 0:a:0 -c:a aac -aac_coder twoloop -ac 2 -ar 48000"
fi
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -map 0:v:0 -map_chapters -1 -map -0:s -map_metadata -1"
FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -fflags +bitexact -flags:v +bitexact -flags:a +bitexact"
if [ "${ROTATE}" != "" ] && [ "$ROTATE" != "0" ]; then
  if [ "${ROTATE}" = "90" ]; then
    FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -vf transpose=1"
  elif [ "${ROTATE}" = "180" ]; then
    FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -vf hflip,vflip"
  elif [ "${ROTATE}" = "270" ]; then
    FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -vf transpose=2"
  fi
fi
if [ "${CROP}" != "" ]; then
  FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -vf crop=${CROP}"
fi
if [ "${ASPECT}" != "" ]; then
  FFMPEG_OUTPUT_OPT="${FFMPEG_OUTPUT_OPT} -aspect ${ASPECT}"
fi
if [ "${INPUT_FILE}" != "" ]; then
  if [ "${YT_DLP}" = "FALSE" ]; then
    echo "ffmpeg ${FFMPEG_INPUT_OPT} -i \"${INPUT_FILE}\" ${FFMPEG_OUTPUT_OPT} ${N16}.mp4"
    bash -c "ffmpeg ${FFMPEG_INPUT_OPT} -i \"${INPUT_FILE}\" ${FFMPEG_OUTPUT_OPT} ${N16}.mp4"
  else
    YT_DLP_OPT="--recode-video mp4"
    YT_DLP_OPT="${YT_DLP_OPT} --format-sort \"vcodec:h265,quality,res,fps,hdr:12,acodec:aac\""
    YT_DLP_OPT="${YT_DLP_OPT} --downloader-args 'ffmpeg:${FFMPEG_INPUT_OPT}'"
    YT_DLP_OPT="${YT_DLP_OPT} --postprocessor-args 'ffmpeg:${FFMPEG_OUTPUT_OPT}'"
    YT_DLP_OPT="${YT_DLP_OPT} --output ${N16}.mp4"
    echo "yt-dlp ${YT_DLP_OPT} \"${INPUT_FILE}\""
    bash -c "yt-dlp ${YT_DLP_OPT} \"${INPUT_FILE}\""
  fi
  echo "chmod 600 ${N16}.mp4"
  chmod 600 ${N16}.mp4
fi

if [ "${M3U8}" = "TRUE" ]; then
  rm -rfv download${DOWNLOAD_INDEX}.m3u8
fi
